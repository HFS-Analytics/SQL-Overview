# The Query Structure

A SQL query is formatted in a statement which describes the shape and structure of the outputted data. Each statement will comprise clauses, which each convey a specifc aspect of the data requested. Here we will discuss the basic clauses of a SQL statement: SELECT, FROM, and WHERE. In the next lesson, we will discuss some further clauses.

Suppose I wanted to bake a pie, and asked you to go find me a pumpkin, at the local pumpkin patch, that is ripe and at least 10 lb in weight. You go to the patch, but this late in the season there are only three left: 
* one is ripe, but only weighs 5 lb
* one weighs 12 lb, but is rotten
* the last is 10 lb exactly and perfectly ripe. 

You reject the first two, bring me the third, and we enjoy some delicious pie that evening.

![That's a great pumpkin you have there!](https://upload.wikimedia.org/wikipedia/en/7/74/GreatPumpkin.jpg)

Many SQL queries are phrased just like my request for a pumpkin. We specify the columns (or gourd) we want, where from (a set of tables or a pumpkin patch), and what criteria we will use to accept or reject each finding.

```SQL
SELECT pumpkin_id
FROM pumpkin_patch
WHERE is_ripe = 1 AND pumpkin_weight >= 10
```

From here, we will discuss in more detail how queries are phrased. Please note that SQL is **not** case-sensitive, but I will tend to capitalize keywords defined in the language as a convention. SQL also generally does not care about line breaks and a query can be written in a single line or across multiple lines. However, I will strive to use line breaks to emphasize the order and structure of each query.

## SELECT
In the select clause, we indicate which _columns_ from the result set we want to display. Commas will separate each column in the list, but common mistakes include omitting commas between columns and adding a comma after the last column.

For example, let's talk about dogs.

![¡Qué guapo!](https://upload.wikimedia.org/wikipedia/commons/e/e0/Youngtoyxolo.jpg)

<details>
  <summary>
Heartland Family Shelter (HFS) is a non-profit, no-kill shelter finding homes for very good dogs since 1870. We have a list of very good dogs adopted from the shelter <a href = "https://github.com/HFS-Analytics/SQL-Overview/blob/main/Dogs.csv"> here</a>)
    </summary>
**Note:** These are fictional dogs generated from data provided by <a href = "https://akc.org"> the American Kennel Club</a>. Any resemblence to actual dogs, living or in Heaven, is completely coincidental.
  
</details>

Here are the first five rows for reference:

```sql
SELECT TOP 5
Dog_ID,
Dog_Name,
Sex,
Breed_ID,
Weight,
Age_at_Intake,
Fixed_at_Intake
From Adoption_Record
```

Dog_ID|Dog_Name|Sex|Breed_ID|Weight|Age_at_Intake|Fixed_at_Intake
:---:|:---:|:---:|:---:|:---:|:---:|:---:
1|LUNA|Female|86|11|0|0
2|BELLA|Female|140|13|9|0
3|DAISY|Female|120|50|12|0
4|LUCY|Female|153|30|2|0
5|BAILEY|Female|174|41|6|0

The columns here represent:
* a unique ID number for each dog, 
* the dog's name, sex (male or female), 
* an ID number for the dog's breed, 
* a weight measurement (in pounds) collected at intake, 
* the dog's estimated age (in human years) at intake, and 
* an indicator for whether or not the dog was already spayed or neutered ("fixed") at the time of intake into the shelter (1 = yes, 0 = no)

Thw `TOP` keyword after select limits the result set to the first 5 records.

In a query, especially one drawing from multiple tables, we may come across columns we do not need in order to answer our current question or which provide us redundant information. Explicitly listing out the columns we want helps assure that the information we need does not get lost among the data we don't. *However, we have the option to pull in all columns from the result set using `SELECT *` or all columns from a particular table using `SELECT Table_Name.*`

Column specifications in the SELECT statement follow this pattern:
`TABLE_NAME.COLUMN_NAME AS ALIAS`

Including the column name helps ensure we get the correct column, especially when multiple tables contain a column with the same name. For example, both dogs and humans have names, but many humans will take offense if you call them by the dog's name (though most dogs don't seem to mind whose name you use).

An alias is a temporary name (only reflected in the output of the query) that we can assign to a column to make it easier to read or to recognize what it represents. This is particularly useful to distinguish multiple columns that have the same name within their respective tables, or to label the result of a calculation. Aliases only apply to the result, so if a column is referenced more than once or is referenced outside the `SELECT` clause, the alias will not be understood.

```sql
SELECT TOP 5
Name AS Pupper,
Breed_ID,
Age_at_Intake * 7 as Age_in_Dog_Years
FROM Dogs
```

Pupper|Breed_ID|Age_in_Dog_Years
:---:|:---:|:---:|
LUNA|86|0
BELLA|140|63
DAISY|120|84
LUCY|153|14
BAILEY|174|42

*Note:* The `AS` keyword is optional, and `Name AS Pupper` is equivalent to `Name Pupper`, but the former is easier to read. In the following query, we make the mistake of leaving out a comma between the two column names:

```sql
SELECT TOP 5
Dog_Name
Breed_ID
From Dogs
```

Breed_ID
:---:|
LUNA
BELLA
DAISY
LUCY
BAILEY

The result will be the contents of the `Name` column, but with an alias of `Breed_ID`, so be careful to place commas where appropriate.

### Calculations

We can also define new columns within the `SELECT` clause. 

**Constant values** (all rows have the same value within a query) are defined by typing the single value for the constant and assigning it an alias:

```sql
SELECT TOP 5
Dog_Name,
10 AS Goodness
From Dogs
```

Dog_Name|Goodness
:---:|:---:|
LUNA|10
BELLA|10
DAISY|10
LUCY|10
BAILEY|10

The above query will return each dog's name with a goodness rating of 10 for each (they are all good dogs, after all).

**Mathematical Operators** can be placed between two values to produce a result applied to each row of the result set, e.g.,

```sql
SELECT top 5
Dog_Name,
Age_at_Intake + Weight as Age_Weight
FROM Dogs
```

Dog_Name|Age_Weight
:---:|:---:
LUNA|11
BELLA|22
DAISY|62
LUCY|32
BAILEY|47

Operator | Use 
|:---:|:---
\+ | Addition
\- | Subtraction
\* | Multiplication
/ | Division

The addition operator (\+) can also be used to combine text:
```sql
SELECT
2 + 2 -- yields 4
"Bow" + "-" + "wow!" -- yields 'Bow-wow!'
```

**Branching logic:** `CASE` statements and the `IIF` function are useful for reflecting branching logic according to the value of one or more columns. The statement starts with `CASE`, ends with `END`, and between are pairs of logical conditions and output values. These tests are conducted in order and the first test to be true determines the result of the calculation. Both of these features rely on Boolean logic, which is described a little more fully under the `WHERE` section below.

 ```sql
 SELECT
 CASE
   WHEN Age <= 1 THEN "Just a pup!"
   WHEN Age > 10 THEN "A senior dog"
   ELSE "A very good dog"
 END AS Age_Group
 FROM Adoption_Record
  ```
  
  `IIF` evaluates a test in the first argument, then returns the value of the second argument if true, or the second if false, e.g., `IIF(Sex = "Female", "A good girl!", "A good dog!")`
  
SQL does not have a single data type that directly represents true or false values, so we will often use 1 and 0, respectively as the result of `CASE` or `IIF` when all we want is an indicator of whether or not a condition is true.

## FROM

## WHERE

**Boolean Operators** 

The following operators compare two values and test for equality or inequality:

Operator | Use 
|:---:|:---
= | Equal to
<> | Not Equal to
< | Less Than
<= | Less Than or Equal to
\> | Greater Than
\>= | Greater Than or Equal to

Inequalities between numeric values are conducted as most people would expect.
*  `3 < 10` is true
*  `10 < 3` is false

However, text values can also be compared as inequalities, using lexical (dictionary) ordering, meaning < and > test whether the first value is alphabetically before or after the second value.
* `"a" < "z"` is true
* `"dogs" > "cats"` is true
* `"3" < "10"` is false, because `"3"` and `"10"` are treated as text (strings of characters), and "3" comes 'alphabetically' after "1"

This leads into another feature that surprises a lot of people: dates are formatted as YYYY-MM-DD, or year-month-day. For example:
* December 7, 1941 is `1941-12-07`
* The earliest date that can be represented is often [January 1, 1753](https://stackoverflow.com/questions/3310569/what-is-the-significance-of-1-1-1753-in-sql-server), or `1753-01-01`
* The latest date that can be represented is often December 31, 9999, or `9999-12-31`

A benefit here is that dates can be represented as strings and compared in dictionary order.
* `2022-09-19` is before `2023-01-01` both chronologically and alphabetically, but `09/19/2022` would not be alphabetically before '01/01/2023'

**Negation:** A `NOT` before a logical test also negates the test, so `1 <> 2` is equivalent to `NOT (1 = 2)`

**Null:** Boolean tests return NULL when any value is compared to NULL, so use `ISNULL` to supply a default value. For example `ISNULL(Breed, "")` would give the breed for each dog, but if a dog's breed is not known, it will insert an empty string (the emptiness between the two quotation marks), and we can test whether `ISNULL(Breed, "") = "Xoloitzcuintli"`.
